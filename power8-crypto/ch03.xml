<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch03">
  <title>Runtime features</title>
  <para><indexterm><primary>Feature detection</primary></indexterm><indexterm><primary>Feature detection</primary><secondary>AIX</secondary></indexterm>Runtime feature detections allows code to switch to a faster implementation when the hardware permits. This chapter shows you how to determine POWER8 cryptography availability at runtime on AIX and Linux PowerPC platforms.</para>
  <section id="feature_strategy">
    <title>Strategy</title>
    <para>The strategy to detect availability of in-core cryptography on POWER processors is check for ISA 2.07 or above. All POWER8 and above machines implement ISA 2.07.</para>
    <para>AIX does not provide separate bits for AES, SHA and polynomial multiplies. You infer the availability of the cryptography support based on the ISA level.</para>
    <para>There is no need to perform <systemitem>SIGILL</systemitem> probes on AIX or Linux.</para>
  </section>
  <section id="feature_aix">
    <title>AIX features</title>
    <para><indexterm><primary>Feature detection</primary><secondary>AIX</secondary></indexterm>The AIX system header <systemitem>&lt;systemcfg.h&gt;</systemitem> defines the <systemitem>_system_configuration</systemitem> structure that identifies system characteristics. The header also provides macros to access various fields of the structure. Runtime code to perform the POWER8 cryptography check should look similar to below.</para>
    <programlisting><indexterm><primary>__power_8_andup</primary></indexterm>#include &lt;sys/systemcfg.h&gt;

#ifndef __power_8_andup
# define __power_8_andup() 0
#endif

// POWER8 and above
bool HasPower8()
{
    if (__power_8_andup() != 0)
        return true;
    return false;
}

bool HasCrypto()
{
    if (__power_8_andup() != 0)
        return true;
    return false;
}
</programlisting>
    <para><indexterm><primary>__power_vsx</primary></indexterm>You <emphasis>should not</emphasis> use the <systemitem>__power_vsx()</systemitem> macro to detect in-core cryptography availability. Though cryptography is implemented in the VSX unit, the VSX unit is available in POWER7 and above.</para>
    <para>OpenSSL uses the following on AIX to test for cryptography availability in <ulink url="https://github.com/openssl/openssl/blob/master/crypto/ppccap.c"><systemitem>crypto/ppccap.c</systemitem></ulink>. The project effectively re-implements the <systemitem>__power_8_andup()</systemitem> macro.</para>
    <programlisting><indexterm><primary>__power_set</primary></indexterm>/* POWER8 and later */
if (__power_set(0xffffffffU&lt;&lt;16))
    OPENSSL_ppccap_P |= PPC_CRYPTO207;
</programlisting>
  </section>
  <section id="feature_linux">
    <title>Linux features</title>
    <para><indexterm><primary>Feature detection</primary><secondary>Linux</secondary></indexterm><indexterm><primary>Glibc</primary></indexterm>Some versions of Glibc and the kernel provide ELF auxiliary vectors with system information. <systemitem>AT_HWCAP2</systemitem> will show the <systemitem>vcrypto</systemitem> flag when in-core crypto is available. This is guaranteed for the following little-endian Linux distributions:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>Ubuntu 14.04 and later</para>
      </listitem>
      <listitem>
        <para>SLES 12 and later</para>
      </listitem>
      <listitem>
        <para>RHEL 7 and later</para>
      </listitem>
    </itemizedlist>
    <para>Below is a screen capture using the loader's diagnostics to print the auxiliary vector for the <systemitem>/bin/true</systemitem> program on <systemitem>gcc112</systemitem>.</para>
    <screen>$ LD_SHOW_AUXV=1 /bin/true
AT_DCACHEBSIZE:  0x80
AT_ICACHEBSIZE:  0x80
AT_UCACHEBSIZE:  0x0
AT_SYSINFO_EHDR: 0x3fff877c0000
AT_HWCAP:        ppcle true_le  archpmu vsx arch_2_06 dfp ic_snoop
                 smt mmu fpu altivec ppc64 ppc32
AT_PAGESZ:       65536
AT_CLKTCK:       100
AT_PHDR:         0x10000040
AT_PHENT:        56
AT_PHNUM:        9
AT_BASE:         0x3fff877e0000
AT_FLAGS:        0x0
AT_ENTRY:        0x1000145c
AT_UID:          10455
AT_EUID:         10455
AT_GID:          10455
AT_EGID:         10455
AT_SECURE:       0
AT_RANDOM:       0x3fffeaeaa872
AT_HWCAP2:       vcrypto tar isel ebb dscr htm arch_2_07
AT_EXECFN:       /bin/true
AT_PLATFORM:     power8
AT_BASE_PLATFORM:power8
</screen>
    <indexterm>
      <primary>Feature detection</primary>
      <secondary>Glibc</secondary>
    </indexterm>
    <para>Linux systems with Glibc version 2.16 can use <systemitem>getauxval</systemitem> to determine CPU features. Runtime code to perform the check should look similar to below. The defines were taken from the Linux kernel's <ulink url="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/include/asm/cputable.h">cputable.h</ulink>.</para>
    <programlisting><indexterm><primary>getauxval</primary></indexterm>#ifndef AT_HWCAP2
# define AT_HWCAP2 26
#endif
#ifndef PPC_FEATURE2_ARCH_2_07
# define PPC_FEATURE2_ARCH_2_07   0x80000000
#endif
#ifndef PPC_FEATURE2_VEC_CRYPTO
# define PPC_FEATURE2_VEC_CRYPTO  0x02000000
#endif

// POWER8 and above
bool HasPower8()
{
    if (getauxval(AT_HWCAP2) &amp; PPC_FEATURE2_ARCH_2_07 != 0)
        return true;
    return false;
}

bool HasCrypto()
{
    if (getauxval(AT_HWCAP2) &amp; PPC_FEATURE2_VEC_CRYPTO != 0)
        return true;
    return false;
}
</programlisting>
  </section>
  <section id="feature_cache_size">
    <title>L1 Data Cache</title>
    <para><indexterm><primary>L1 data cache</primary></indexterm>The L1 data cache line size is an important security parameter that can be used to avoid leaking information through timing attacks. IBM POWER System S822, like <systemitem>gcc112</systemitem> and <systemitem>gcc119</systemitem>, have a 128-byte L1 data cache line size.</para>
    <para><indexterm><primary>L1 data cache</primary><secondary>AIX</secondary></indexterm><systemitem>gcc119</systemitem> runs AIX and a program can query the L1 data cache line size as shown below.</para>
    <programlisting><indexterm><primary>getsystemcfg</primary></indexterm>#include &lt;sys/systemcfg.h&gt;

int cacheLineSize = getsystemcfg(SC_L1C_DLS);
if (cacheLineSize) &lt;= 0)
    cacheLineSize = DEFAULT_L1_CACHE_LINE_SIZE;
</programlisting>
    <para><indexterm><primary>L1 data cache</primary><secondary>Linux</secondary></indexterm><systemitem>gcc112</systemitem> runs Linux and a program can query the L1 data cache line size as shown below.</para>
    <programlisting><indexterm><primary>sysconf</primary></indexterm>#include &lt;sys/sysconf.h&gt;

int cacheLineSize = sysconf(_SC_LEVEL1_DCACHE_LINESIZE);
if (cacheLineSize) &lt;= 0)
    cacheLineSize = DEFAULT_L1_CACHE_LINE_SIZE;
</programlisting>
    <para>It is important to check the return value from <systemitem>sysconf</systemitem> on Linux. <systemitem>gcc112</systemitem> runs CentOS 7.4 and the machine returns 0 for the L1 cache line query. Also see <ulink url="https://lists.centos.org/pipermail/centos/2017-September/166236.html">sysconf and _SC_LEVEL1_DCACHE_LINESIZE returns 0?</ulink> on the CentOS mailing list.</para>
  </section>
</chapter>
