<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch07">
  <title>Assembly language</title>
  <indexterm>
    <primary>Assembly language</primary>
  </indexterm>
  <para>This chapter demonstrates building and linking against SHA assembly language routines. The source code is available on GitHubs and shows the steps for integration of the projects without the baggage of a full blown library.</para>
  <section id="asm_cryptogams">
    <title>Cryptogams</title>
    <indexterm>
      <primary>Cryptogams</primary>
    </indexterm>
    <indexterm>
      <primary>Andy Polyakov</primary>
    </indexterm>
    <indexterm>
      <primary>Cryptogams</primary>
      <secondary>Andy Polyakov</secondary>
    </indexterm>
    <para><ulink url="https://www.openssl.org/~appro/cryptogams/">Cryptogams</ulink> is Andy Polyakov's incubator to develop assembly language routines for OpenSSL. Andy dual licenses his implementations, so a more permissive license is available for the assembly language source code. This section will show you how to build Andy's software.</para>
    <para/>
  </section>
  <section id="asm_sha2_le">
    <title>sha2-le</title>
    <indexterm>
      <primary>sha2-le</primary>
    </indexterm>
    <indexterm>
      <primary>Gustavo Serra Scalet</primary>
    </indexterm>
    <indexterm>
      <primary>sha2-le</primary>
      <secondary>Gustavo Serra Scalet</secondary>
    </indexterm>
    <indexterm>
      <primary>SHA-256</primary>
      <secondary>sha2-le</secondary>
    </indexterm>
    <para>The <ulink url="https://github.com/PPC64/sha2-le/">PPC64 team on GitHub</ulink> has a SHA-256 assembly implementation built using <systemitem>m4</systemitem> macros. This section explains how to build the assembly source file, create a test program and link against the assembly-based object file.</para>
    <para>The team only provides little-endian so you will need to modify the source files for big-endian. There is a <ulink url="https://github.com/PPC64/sha2-le/pull/6">pull request</ulink> that will be useful if you want both little-endian and big-endian support.</para>
    <para>The steps that follow were carried out on <systemitem>gcc112</systemitem>, which is ppc64-le. To begin clone the project, build the sources and test the program.</para>
    <screen>$ git clone https://github.com/PPC64/sha2-le.git
$ cd sha2-le
...

$ make COMPILERS=gcc
...

$ make test COMPILERS=gcc
...

========================================================
Testing gcc
========================================================
./bin/test256_gcc
./bin/test512_gcc
CC=gcc ./blackbox-test.sh
Running tests for SHA-256:
Test #1:        sha2-le is Ok   libcrypto is Ok c is Ok
Test #2:        sha2-le is Ok   libcrypto is Ok c is Ok
Test #3:        sha2-le is Ok   libcrypto is Ok c is Ok
Test #4:        sha2-le is Ok   libcrypto is Ok c is Ok
...
</screen>
    <para>Next, create the assembly language source file from m4 sources, and then create the object file by assembling the source file.</para>
    <screen>$ make clean
...

$ m4 common.m4 sha256_compress_ppc.m4 &gt; sha256_compress.s
$ as -mpower8 sha256_compress.s -o sha256_compress.o
</screen>
    <para>You can examine the disassembly with the following command. The output below shows round calculations.</para>
    <screen>$ objdump --disassemble sha256_compress.o
sha256_compress.o:     file format elf64-powerpcle

Disassembly of section .text:

0000000000000000 &lt;sha256_compress_ppc&gt;:

 ...
 144:   6a 73 0f 10     vsel    v0,v15,v14,v13
 148:   c4 54 29 10     vxor    v1,v9,v10
 14c:   82 fe 6d 10     vshasigmaw v3,v13,1,15
 150:   80 d0 c0 10     vadduwm v6,v0,v26
 154:   80 18 b0 10     vadduwm v5,v16,v3
 158:   6a 58 2a 10     vsel    v1,v10,v11,v1
 15c:   80 30 e5 10     vadduwm v7,v5,v6
 160:   82 86 49 10     vshasigmaw v2,v9,1,0
 164:   80 08 02 11     vadduwm v8,v2,v1
 168:   80 38 8c 11     vadduwm v12,v12,v7
 16c:   80 40 07 12     vadduwm v16,v7,v8
 ...
</screen>
    <para>The comments in <systemitem>sha256_compress.s</systemitem> state the public API for the function is as follows. The documentation does not state the alignment requirements of <systemitem>state</systemitem>, <systemitem>input</systemitem> or <systemitem>keys</systemitem>. When in doubt you should align the memory to a 16-byte boundary.</para>
    <screen>void sha256_compress_ppc(
    uint32_t *state,
    const uint8_t *input,
    const uint32_t *keys)
</screen>
    <para>Finally, a program that links to sha2-le's <systemitem>sha256_compress_ppc</systemitem> might look like the following.</para>
    <programlisting>$ cat test.cxx
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

extern "C" {
  void sha256_compress_ppc(uint32_t*,
              const uint8_t*, const uint32_t*);
}

#define ALIGN16 __attribute__((aligned(16)))

const ALIGN16 uint32_t K256[] =
  {
    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
  };

int main(int argc, char* argv[])
{
  /* empty message with padding */
  ALIGN16 uint8_t message[64];
  memset(message, 0x00, sizeof(message));
  message[0] = 0x80;

  /* initial state */
  ALIGN16 uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  sha256_compress_ppc(state, message, K256);

  const uint8_t b1 = (uint8_t)(state[0] &gt;&gt; 24);
  const uint8_t b2 = (uint8_t)(state[0] &gt;&gt; 16);
  const uint8_t b3 = (uint8_t)(state[0] &gt;&gt;  8);
  const uint8_t b4 = (uint8_t)(state[0] &gt;&gt;  0);
  const uint8_t b5 = (uint8_t)(state[1] &gt;&gt; 24);
  const uint8_t b6 = (uint8_t)(state[1] &gt;&gt; 16);
  const uint8_t b7 = (uint8_t)(state[1] &gt;&gt;  8);
  const uint8_t b8 = (uint8_t)(state[1] &gt;&gt;  0);

  /* e3b0c44298fc1c14... */
  printf("SHA256 hash of empty message: ");
  printf("%02X%02X%02X%02X%02X%02X%02X%02X...\n",
         b1, b2, b3, b4, b5, b6, b7, b8);

  int success = ((b1 == 0xE3) &amp;&amp; (b2 == 0xB0) &amp;&amp;
                 (b3 == 0xC4) &amp;&amp; (b4 == 0x42) &amp;&amp;
                 (b5 == 0x98) &amp;&amp; (b6 == 0xFC) &amp;&amp;
                 (b7 == 0x1C) &amp;&amp; (b8 == 0x14));

  if (success)
    printf("Success!\n");
  else
    printf("Failure!\n");

  return (success != 0 ? 0 : 1);
}
</programlisting>
    <para>Compiling and linking to <systemitem>sha256_compress_ppc.o</systemitem> would look similar to below.</para>
    <programlisting>$ g++ test.cxx -o test.exe sha256_compress.o
$ ./test.exe
SHA256 hash of empty message: E3B0C44298FC1C14...
Success!
</programlisting>
  </section>
</chapter>
