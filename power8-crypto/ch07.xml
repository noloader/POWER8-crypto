<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch07">
  <title>Assembly language</title>
  <indexterm>
    <primary>Assembly language</primary>
  </indexterm>
  <para>This chapter shows you how to build and link against projects that provide POWER8 SHA assembly language routines. Two projects are used. The first is Andy Polyakov's Cryptogams, and second is the PPC64 team's sha2-le. Andy's implementations are well respected and world renowned. The PPC64 team's implementation is no longer maintained.</para>
  <section id="asm_cryptogams">
    <title>Cryptogams</title>
    <indexterm>
      <primary>Cryptogams</primary>
    </indexterm>
    <indexterm>
      <primary>Andy Polyakov</primary>
    </indexterm>
    <indexterm>
      <primary>Cryptogams</primary>
      <secondary>Andy Polyakov</secondary>
    </indexterm>
    <para><ulink url="https://www.openssl.org/~appro/cryptogams/">Cryptogams</ulink> is Andy Polyakov's incubator to develop assembly language routines for OpenSSL. Andy dual licenses his implementations and a more permissive license is available for his assembly language source code. This section will show you how to use Cryptogams' SHA-256 implementation.</para>
    <para>The steps that follow were carried out on <systemitem>gcc112</systemitem>, which is ppc64-le. Andy's GitHub is located at <ulink url="https://github.com/dot-asm">dot-asm</ulink>, so clone the project and read the README.</para>
    <screen>$ git clone https://github.com/dot-asm/cryptogams
$ cd cryptogams
</screen>
    <para>The README contains instructions for using the source files:</para>
    <blockquote>
      <para>"Flavour" refers to ABI family or specific OS. E.g. x86_64 scripts recognize 'elf', 'elf32', 'macosx', 'mingw64', 'nasm'. PPC scripts recognize 'linux32', 'linux64', 'linux64le', 'aix32', 'aix64', 'osx32', 'osx64', and so on...</para>
    </blockquote>
    <para>Unfortunately Andy has not uploaded the SHA gear to Cryptogams so you will have to switch to OpenSSL to get the Cryptogams sources. Make a <systemitem>cryptogams</systemitem> directory, and then copy <systemitem>sha512p8-ppc.pl</systemitem> and <systemitem>ppc-xlate.pl</systemitem> from the OpenSSL source directory:</para>
    <screen>$ mkdir cryptogams
$ cp openssl/crypto/sha/asm/sha512p8-ppc.pl cryptogams/
$ cp openssl/crypto/perlasm/ppc-xlate.pl cryptogams/
$ cd cryptogams/</screen>
    <para>Next examine the head notes in <systemitem>sha512p8-ppc.pl</systemitem>, which is used to create the source files for SHA-256 and SHA-512. The comments say the script takes two arguments. The first is a <quote>flavor</quote>, and the 32 or 64 is used to convey the platform architecture. Adding <quote>le</quote> to flavor will produce a source file for a little endian machine. The second argument is <quote>output</quote>, and 256 or 512 in the output filename selects either SHA-256 or SHA-512.</para>
    <para>The commands to produce a SHA-256 assembly source file for <systemitem>gcc112</systemitem> and assemble it are shown below.</para>
    <screen>$ ./sha512p8-ppc.pl linux64le sha256le_compress.s
$ as -mpower8 sha256le_compress.s -o sha256le_compress.o
</screen>
    <para>The head notes in <systemitem>sha512p8-ppc.pl</systemitem> do not state the public API. However the source file <systemitem>crypto/ppccap.c</systemitem> says:</para>
    <screen>$ grep -IR sha256_block_p8 *
crypto/ppccap.c:void sha256_block_p8(void *ctx, const void *inp,
size_t len);
...</screen>
    <para>In fact the signature for <systemitem>sha256_block_p8</systemitem> is better documented as shown below. There are no alignment requirements for <systemitem>state</systemitem> or <systemitem>input</systemitem>.</para>
    <programlisting>void sha256_block_p8(uint32_t *state,
            const uint8_t *input, size_t blocks);
</programlisting>
    <para>Finally, a program that links to <systemitem>sha256_block_p8</systemitem> might look like the following.</para>
    <programlisting>$ cat test.cxx
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

extern "C" {
  void sha256_block_p8(uint32_t*, const uint8_t*, size_t);
}

int main(int argc, char* argv[])
{
  /* empty message with padding */
  uint8_t message[64];
  memset(message, 0x00, sizeof(message));
  message[0] = 0x80;

  /* initial state */
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  size_t blocks = sizeof(message)/64;
  sha256_block_p8(state, message, blocks);

  const uint8_t b1 = (uint8_t)(state[0] &gt;&gt; 24);
  const uint8_t b2 = (uint8_t)(state[0] &gt;&gt; 16);
  const uint8_t b3 = (uint8_t)(state[0] &gt;&gt;  8);
  const uint8_t b4 = (uint8_t)(state[0] &gt;&gt;  0);
  const uint8_t b5 = (uint8_t)(state[1] &gt;&gt; 24);
  const uint8_t b6 = (uint8_t)(state[1] &gt;&gt; 16);
  const uint8_t b7 = (uint8_t)(state[1] &gt;&gt;  8);
  const uint8_t b8 = (uint8_t)(state[1] &gt;&gt;  0);

  /* e3b0c44298fc1c14... */
  printf("SHA256 hash of empty message: ");
  printf("%02X%02X%02X%02X%02X%02X%02X%02X...\n",
         b1, b2, b3, b4, b5, b6, b7, b8);

  int success = ((b1 == 0xE3) &amp;&amp; (b2 == 0xB0) &amp;&amp;
                 (b3 == 0xC4) &amp;&amp; (b4 == 0x42) &amp;&amp;
                 (b5 == 0x98) &amp;&amp; (b6 == 0xFC) &amp;&amp;
                 (b7 == 0x1C) &amp;&amp; (b8 == 0x14));

  if (success)
    printf("Success!\n");
  else
    printf("Failure!\n");

  return (success != 0 ? 0 : 1);
}
</programlisting>
    <para>Compiling and linking to <systemitem>sha256le_compress.o</systemitem> would look similar to below.</para>
    <programlisting>$ g++ -mcpu=power8 test.cxx sha256le_compress.o -o test.exe
$ ./test.exe
SHA256 hash of empty message: E3B0C44298FC1C14...
Success!
</programlisting>
  </section>
  <section id="asm_sha2_le">
    <title>sha2-le</title>
    <indexterm>
      <primary>sha2-le</primary>
    </indexterm>
    <indexterm>
      <primary>Gustavo Serra Scalet</primary>
    </indexterm>
    <indexterm>
      <primary>sha2-le</primary>
      <secondary>Gustavo Serra Scalet</secondary>
    </indexterm>
    <indexterm>
      <primary>SHA-256</primary>
      <secondary>sha2-le</secondary>
    </indexterm>
    <para>The <ulink url="https://github.com/PPC64/sha2-le/">PPC64 team on GitHub</ulink> provide a SHA-256 little-endian implementation built using <systemitem>m4</systemitem> macros. This section explains how to create the assembly source file, and how to create a test program that links against the object file.</para>
    <para>The team only provides little-endian so you will need to modify the source files for big-endian. There is a <ulink url="https://github.com/PPC64/sha2-le/pull/6">pull request</ulink> that will be useful if you want both little-endian and big-endian support.</para>
    <para>The steps that follow were carried out on <systemitem>gcc112</systemitem>, which is ppc64-le. To begin, clone the project. Then, create the assembly language source file from m4 sources, and create the object file by assembling the source file.</para>
    <screen>$ m4 common.m4 sha256_compress_ppc.m4 &gt; sha256_compress.s
$ as -mpower8 sha256_compress.s -o sha256_compress.o
</screen>
    <para>The comments in <systemitem>sha256_compress.s</systemitem> state the public API for the function is as follows. There are no alignment requirements for <systemitem>state</systemitem>, <systemitem>input</systemitem> or <systemitem>keys</systemitem>. The function only operates on 1 block (64 bytes) at a time.</para>
    <screen>void sha256_compress_ppc(uint32_t *state,
            const uint8_t *input, const uint32_t *keys);
</screen>
    <para>Finally, a program that links to <systemitem>sha256_compress_ppc</systemitem> might look like the following.</para>
    <programlisting>$ cat test.cxx
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

extern "C" {
  void sha256_compress_ppc(uint32_t*,
              const uint8_t*, const uint32_t*);
}

const uint32_t K256[] =
{
    0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
    0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
    0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
    0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
    0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
    0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
    0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
    0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
    0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
    0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
    0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
    0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
    0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
    0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
    0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
    0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
};

int main(int argc, char* argv[])
{
  /* empty message with padding */
  uint8_t message[64];
  memset(message, 0x00, sizeof(message));
  message[0] = 0x80;

  /* initial state */
  uint32_t state[8] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  };

  sha256_compress_ppc(state, message, K256);

  const uint8_t b1 = (uint8_t)(state[0] &gt;&gt; 24);
  const uint8_t b2 = (uint8_t)(state[0] &gt;&gt; 16);
  const uint8_t b3 = (uint8_t)(state[0] &gt;&gt;  8);
  const uint8_t b4 = (uint8_t)(state[0] &gt;&gt;  0);
  const uint8_t b5 = (uint8_t)(state[1] &gt;&gt; 24);
  const uint8_t b6 = (uint8_t)(state[1] &gt;&gt; 16);
  const uint8_t b7 = (uint8_t)(state[1] &gt;&gt;  8);
  const uint8_t b8 = (uint8_t)(state[1] &gt;&gt;  0);

  /* e3b0c44298fc1c14... */
  printf("SHA256 hash of empty message: ");
  printf("%02X%02X%02X%02X%02X%02X%02X%02X...\n",
         b1, b2, b3, b4, b5, b6, b7, b8);

  int success = ((b1 == 0xE3) &amp;&amp; (b2 == 0xB0) &amp;&amp;
                 (b3 == 0xC4) &amp;&amp; (b4 == 0x42) &amp;&amp;
                 (b5 == 0x98) &amp;&amp; (b6 == 0xFC) &amp;&amp;
                 (b7 == 0x1C) &amp;&amp; (b8 == 0x14));

  if (success)
    printf("Success!\n");
  else
    printf("Failure!\n");

  return (success != 0 ? 0 : 1);
}
</programlisting>
    <para>Compiling and linking to <systemitem>sha256_compress_ppc.o</systemitem> would look similar to below.</para>
    <programlisting>$ g++ test.cxx sha256_compress.o -o test.exe
$ ./test.exe
SHA256 hash of empty message: E3B0C44298FC1C14...
Success!
</programlisting>
  </section>
</chapter>
