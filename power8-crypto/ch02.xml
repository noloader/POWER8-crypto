<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch02">
  <title>Vector programming</title>
  <para>Several topics need to be discussed to minimize trouble when using the Ativec and POWER8 extensions. They include PowerPC compilers and options, Altivec headers, machine endianness, vector datatypes, memory and alignment, and loads and stores. It is enough information to get to the point you can use AES and SHA but not much more.</para>
  <para>Memory alignment, loads, stores and shifts will probably cause the most trouble for someone new to PowerPC vector programming. If you are new to the platform you may want to read this chapter twice. If you are expereinced with the platform then you probbably want to skip this chapter.</para>
  <section id="power8_compilers">
    <title>PowerPC compilers</title>
    <para>Two compilers are used for testing. The first is GCC and the second is IBM XL C/C++. The compilers are mostly the same but slightly different with its options.</para>
    <para>Compiling a test program with GCC will generally look like below. The important part is <systemitem>-mcpu=power8</systemitem> which selects the POWER8 Instruction Set Architecture (ISA).</para>
    <programlisting>$ g++ -mcpu=power8 test.cxx -o test.exe
</programlisting>
    <para>Complimentary, compiling a test program with IBM XL C/C++ will generally look like below. The important parts are the C++ compiler name of <systemitem>xlC</systemitem>, and <systemitem>-qarch=pwr8</systemitem> which selects the POWER8 ISA.</para>
    <programlisting>$ xlC -qarch=pwr8 -qaltivec test.cxx -o test.exe
</programlisting>
    <para>When compiling source code to examine the quality of code generation the program should be compiled with <systemitem>-O3</systemitem>. Both compilers consume <systemitem>-O3</systemitem>.</para>
  </section>
  <section id="power8_header">
    <title>Altivec headers</title>
    <para>The header required for datatypes and functions is <systemitem>&lt;altivec.h&gt;</systemitem>. To support compiles with a C++ compiler <systemitem>__vector</systemitem> keyword is used rather than <systemitem>vector</systemitem>. A typical Altivec include looks as shown below.</para>
    <programlisting>#if defined(__ALTIVEC__)
# include &lt;altivec.h&gt;
# undef vector
# undef pixel
# undef bool
#endif
</programlisting>
    <para>In addition to <systemitem>__ALTIVEC__</systemitem> preprocessor macro you will see the following defines depending on the platform:</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para><systemitem>__powerpc__</systemitem> and <systemitem>__powerpc</systemitem> on AIX
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__powerpc__</systemitem> and <systemitem>__powerpc64__</systemitem> on Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>_ARCH_PWR3</systemitem> through <systemitem>_ARCH_PWR9</systemitem> on AIX and Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__linux__</systemitem>, <systemitem>__linux</systemitem> and <systemitem>linux</systemitem> on Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>_AIX</systemitem>, and <systemitem>_AIX32</systemitem> through <systemitem>_AIX72</systemitem> on AIX
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__xlc__</systemitem> and <systemitem>__xlC__</systemitem> when using IBM XL C/C++
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section id="power8_endianess">
    <title>Machine endianness</title>
    <para>You will experience both little-endian and big-endian machines in the field when working with a modern PowerPC architecture. Linux is generally little-endian, while AIX is big-endian.</para>
    <para>When writing portable source code you should check the value of preprocessor macros <systemitem>__LITTLE_ENDIAN__</systemitem> or <systemitem>__BIG_ENDIAN__</systemitem> to determine the configuration. The value of the macros <systemitem>__BIG_ENDIAN__</systemitem> and <systemitem>__LITTLE_ENDIAN__</systemitem> are defined to non-0 to activate the macro. Source code checking endianness should look similar to the code shown below.</para>
    <programlisting>#if __LITTLE_ENDIAN__
# error "Little-endian system"
#else
# error "Big-endian system"
#endif
</programlisting>
    <para>The compilers can show the endian related preprocessor macros available on a platform. Below is from GCC on <systemitem>gcc112</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-le.</para>
    <screen>$ g++ -dM -E test.cxx | grep -i endian
#define __ORDER_LITTLE_ENDIAN__ 1234
#define _LITTLE_ENDIAN 1
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __ORDER_PDP_ENDIAN__ 3412
#define __LITTLE_ENDIAN__ 1
#define __ORDER_BIG_ENDIAN__ 4321
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
</screen>
    <para>And the complimentary view from IBM XL C/C++ on <systemitem>gcc112</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-le.</para>
    <screen>$ xlC -qshowmacros -E test.cxx | grep -i endian
#define _LITTLE_ENDIAN 1
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 1
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_PDP_ENDIAN__ 3412
#define __VEC_ELEMENT_REG_ORDER__ __ORDER_LITTLE_ENDIAN__
</screen>
    <para>However, below is <systemitem>gcc119</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-be. It runs AIX and notice <systemitem>__BYTE_ORDER__</systemitem>, <systemitem>__ORDER_BIG_ENDIAN__</systemitem> and <systemitem>__ORDER_LITTLE_ENDIAN__</systemitem> are not present.</para>
    <screen>$ xlC -qshowmacros -E test.cxx | grep -i endian
#define __BIG_ENDIAN__ 1
#define _BIG_ENDIAN 1
#define __THW_BIG_ENDIAN__ 1
#define __HHW_BIG_ENDIAN__ 1
</screen>
  </section>
  <section id="power8_alloc">
    <title>Memory allocation</title>
    <para>System calls like <systemitem>malloc</systemitem> and <systemitem>calloc</systemitem> (and friends) are used to acquire memory from the heap. The system calls <emphasis>do not</emphasis> guarantee aligment to any particular boundary on all platforms. Linux generally returns a pointer that is at least 16-byte aligned on all platforms, including ARM, PPC, MIPS and x86. AIX <emphasis>does not</emphasis> provide the same <ulink url="https://stackoverflow.com/q/48373188/608639">alignment behavior</ulink>.</para>
    <para>To avoid unexpected surprises when using heap allocations you should use <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/posix_memalign.html"><systemitem>posix_memalign</systemitem></ulink> to acquire heap memory aligned to a particular boundary and <systemitem>free</systemitem> to return it to the system.</para>
    <para>AIX provides routines for vector memory allocation and alignment. They are <systemitem>vec_malloc</systemitem> and <systemitem>vec_free</systemitem>, and you can use then like <systemitem>_mm_malloc</systemitem> on Intel machines with Streaming SIMD Extensions (SSE).</para>
  </section>
  <section id="power8_datatypes">
    <title>Vector datatypes</title>
    <para>Three vector datatypes are needed for in-core programming. The three types used for crypto are listed below.</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para>
          <systemitem>__vector unsigned char</systemitem>
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>__vector unsigned int</systemitem>
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>__vector unsigned long</systemitem>
        </para>
      </listitem>
    </itemizedlist>
    <para><systemitem>__vector unsigned char</systemitem> is arranged as 16 each 8-bit bytes, and it is typedef'd as <systemitem>uint8x16_p8</systemitem>. <systemitem>__vector unsigned int</systemitem> is arranged as 4 each 32-bit words, and it is typedef'd as <systemitem>uint32x4_p8</systemitem>.</para>
    <para>POWER8 added <systemitem>__vector unsigned long</systemitem> and associated vector operations. <systemitem>__vector unsigned long</systemitem> is arranged as 2 each 64-bit double words, and it is typedef'd as <systemitem>uint64x2_p8</systemitem>.</para>
    <para>The typedef naming was selected to convey the arrangement, like <systemitem>32x4</systemitem> and <systemitem>64x2</systemitem>. The trailing <systemitem>_p8</systemitem> was selected to avoid collisions with ARM NEON vector data types. The suffix <systemitem>_p</systemitem> (for POWER architecture) or <systemitem>_v</systemitem> (for Vector) would work just as well.</para>
  </section>
  <section id="power8_shift">
    <title>Vector shifts</title>
    <para>Altivec shifts and rotates are performed using <emphasis>Vector Shift Left Double by Octet Immediate</emphasis>. The vector shift and rotate built-in is <systemitem>vec_sld</systemitem> and it compiles/assembles to <systemitem>vsldoi</systemitem>. Both shift and rotate operate on a concatenation of two vectors. Bytes are shifted out on the left and shifted in on the right. The instructions need an integral constant in the range 0 - 15, inclusive.</para>
    <para>Vector shifts and rotates perform as expected on big-endian machines. Little-endian machines need a special handling to produce correct results and the <ulink url="https://www.ibm.com/support/knowledgecenter/SSXVZZ_13.1.4/com.ibm.xlcpp1314.lelinux.doc/compiler_ref/vec_sld.html">IBM manuals don't tell you about it</ulink>. If you are like many other developers then you will literally waste hours trying to figure it out what happened the first time you experience it.</para>
    <para>The issue is <ulink url="https://stackoverflow.com/q/46341923/608639">shifts and rotates are endian sensitive</ulink>, and you have to use <systemitem>16-n</systemitem> and swap vector arguments on little-endian systems. The C++ source code provides the following template function to compensate for the little-endian behavior.</para>
    <programlisting>template &lt;unsigned int N, class T&gt;
T VectorShiftLeft(const T val1, const T val2)
{
#if __LITTLE_ENDIAN__
    enum {R = (16-N)&amp;0xf};
    return vec_sld(val2, val1, R);
#else
    enum {R = N&amp;0xf};
    return vec_sld(val1, val2, R);
#endif
}
</programlisting>
    <para>A <systemitem>VectorRoatetLeft</systemitem> would be similar to the code below, if needed. Rotate is a special case of shift where both vector arguments are the same value.</para>
    <programlisting>template &lt;unsigned int N, class T&gt;
T VectorRotateLeft(const T val)
{
#if __LITTLE_ENDIAN__
    enum {R = (16-N)&amp;0xf};
    return vec_sld(val, val, R);
#else
    enum {R = N&amp;0xf};
    return vec_sld(val, val, R);
#endif
}
</programlisting>
  </section>
  <section id="power8_aligned_ld_st">
    <title>Aligned loads</title>
    <para>Altivec loads and stores have traditionally been performed using <systemitem>vec_ld</systemitem> and <systemitem>vec_st</systemitem> since at least the POWER4 days in the early 2000s. <systemitem>vec_ld</systemitem> and <systemitem>vec_st</systemitem> are sensitive to alignment of the memory address and the offset into the address. The effective address is the sum <systemitem>address+offset</systemitem> rounded down or masked to a multiple of 16.</para>
    <para>Altivec <emphasis>does not</emphasis> raise a <systemitem>SIGBUS</systemitem> to indicate a misaligned load or store. Instead, the bottom 4 bits of the sum <systemitem>address+offset</systemitem> are masked-off and then the memory at the effective address is loaded.</para>
    <para>You can use the Altivec loads and stores when you <emphasis>control</emphasis> buffers and ensure they are 16-byte aligned, like an AES key schedule table. Otherwise just use <link linkend="power8_unaligned_ld_st">unaligned loads and stores</link> to avoid trouble.</para>
    <para>The C/C++ code to perform a load using <systemitem>vec_ld</systemitem> should look similar to below. Notice the <systemitem>assert</systemitem> to warn you of problems in debug builds.</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoad(const T* mem_addr, int offset)
{
#ifndef NDEBUG
    uintptr_t maddr = ((uintptr_t)mem_addr)+offset;
    uintptr_t mask = ~(uintptr_t)0xf;
    uintptr_t eaddr = maddr &amp; mask;
    assert(maddr == eaddr);
#endif

    return (uint32x4_p8)vec_ld(offset, (uint8_t*)mem_addr);
}
</programlisting>
    <para>The C/C++ code to perform a store using <systemitem>vec_st</systemitem> should look similar to below.</para>
    <programlisting>template &lt;class T&gt;
void VectorStore(T* mem_addr, int offset)
{
#ifndef NDEBUG
    uintptr_t maddr = ((uintptr_t)mem_addr)+offset;
    uintptr_t mask = ~(uintptr_t)0xf;
    uintptr_t eaddr = maddr &amp; mask;
    assert(maddr == eaddr);
#endif

    vec_st(offset, (uint8_t*)mem_addr);
}
</programlisting>
    <para>Casting away <systemitem>const</systemitem>-ness on <systemitem>mem_addr</systemitem> is discussed in <link linkend="power8_const_ptr"><systemitem>const</systemitem> pointers</link> below.</para>
  </section>
  <section id="power8_unaligned_ld_st">
    <title>Unaligned loads</title>
    <para>POWER7 introduced unaligned loads and stores that avoid the aligned memory requirements. The instructions for unaligned loads and stores are <systemitem>vec_vsx_ld</systemitem> and <systemitem>vec_vsx_st</systemitem> for GCC; and <systemitem>vec_xl</systemitem> and <systemitem>vec_xst</systemitem> for XLC.</para>
    <para>You should use the POWER7 loads and stores whenever you <emphasis>do not control</emphasis> buffers or their alignments, like messages supplied by user code.</para>
    <para>The C/C++ code to perform a load using <systemitem>vec_xl</systemitem> and <systemitem>vec_vsx_ld</systemitem> should look similar to below. The function name has a <systemitem>u</systemitem> added to indicate unaligned.</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoadu(const T* mem_addr, int offset)
{
#if defined(__xlc__) || defined(__xlC__)
    return (uint32x4_p8)vec_xl(offset, (uint8_t*)mem_addr);
#else
    return (uint32x4_p8)vec_vsx_ld(offset, (uint8_t*)mem_addr);
#endif
}
</programlisting>
    <para>The C/C++ code to perform a store using <systemitem>vec_xst</systemitem> and <systemitem>vec_vsx_st</systemitem> should look similar to below.</para>
    <programlisting>template &lt;class T&gt;
void VectorStoreu(T* mem_addr, int offset)
{
#if defined(__xlc__) || defined(__xlC__)
    vec_xst((uint8x16_p8)val, offset, (uint8_t*)mem_addr);
#else
    vec_vsx_st((uint8x16_p8)val, offset, (uint8_t*)mem_addr);
#endif
}
</programlisting>
    <para>Casting away <systemitem>const</systemitem>-ness on <systemitem>mem_addr</systemitem> is discussed in <link linkend="power8_const_ptr"><systemitem>const</systemitem> pointers</link> below.</para>
  </section>
  <section id="power8_vec_ld_be">
    <title>Big-endian loads</title>
    <para>TODO: talk about <systemitem>vec_xl_be</systemitem> when using XLC, and the assembly replacement <systemitem>VEC_XL_BE</systemitem> when using GCC.</para>
  </section>
  <section id="power8_vec_ld_deref">
    <title>Vector dereferences</title>
    <para>The <ulink url="http://openpowerfoundation.org/wp-content/uploads/resources/leabi/content/dbdoclet.50655244_39970.html">OpenPOWER manual states</ulink> use vector pointers and dereferences to perform loads and stores: <quote>The preferred way to access vectors at an application-defined address is by using vector pointers and the C/C+⁠+ dereference operator *.</quote> The example from the manual is shown below.</para>
    <programlisting>vector char vca;
vector char vcb;
vector int via;
int a[4];
void *vp;

via = *(vector int *) &amp;a[0];
vca = (vector char) via;
vcb = vca;
vca = *(vector char *)vp;
*(vector char *)&amp;a[0] = vca;
</programlisting>
    <para>The technique requires aligned memory addresses so you should use it with care. The easiest way to ensure trouble free loads and stores is to perform <link linkend="power8_unaligned_ld_st">unaligned loads and stores</link>.</para>
  </section>
  <section id="power8_const_ptr">
    <title>Const pointers</title>
    <para>The Altivec built-ins have an unusual behavior when it comes to <systemitem>const</systemitem> pointers used during a load operation. A program runs slower when the memory is marked as <systemitem>const</systemitem>. The behavior has been witnessed in two libraries and the decrease in perfromance is measurable. For example, <ulink url="https://github.com/randombit/botan/pull/1459">AES runs 0.3 to 0.5 cycles per byte (cpb) faster</ulink> when non-<systemitem>const</systemitem> pointers are used for loads. 0.3 cpb may not sound like much but it equates to 200 MiB/s for AES-128 on <systemitem>gcc112</systemitem>.</para>
    <para>Source code using the <systemitem>non-const</systemitem> pointers should look similar to below:</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoad(const T* mem_addr, int offset)
{
    // mem_addr must be aligned to 16-byte boundary
    return (uint32x4_p8)vec_ld(offset, (uint8_t*)mem_addr);
}
</programlisting>
  </section>
</chapter>
