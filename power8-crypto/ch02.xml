<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="ch02">
  <title>Vector programming</title>
  <para>Several topics need to be discussed to minimize trouble when using the Altivec and POWER8 extensions. They include PowerPC compilers and options, Altivec headers, machine endianness, vector datatypes, memory and alignment, and loads and stores. It is enough information to get to the point you can use AES and SHA but not much more.</para>
  <para>Memory alignment, loads, stores and shifts will probably cause the most trouble for someone new to PowerPC vector programming. If you are new to the platform you may want to read this chapter twice. If you are experienced with the platform then you probably want to skip this chapter.</para>
  <section id="power8_compilers">
    <title>PowerPC compilers</title>
    <para>Two compilers are used for testing. The first is GCC and the second is IBM XL C/C++. The compilers are mostly the same but accept slightly different options.</para>
    <para>Compiling a test program with GCC will generally look like below. The important part is <systemitem>-mcpu=power8</systemitem> which selects the POWER8 Instruction Set Architecture (ISA).</para>
    <programlisting>$ g++ -mcpu=power8 test.cxx -o test.exe
</programlisting>
    <para>Complimentary, compiling a test program with IBM XL C/C++ will generally look like below. The important parts are the C++ compiler name of <systemitem>xlC</systemitem>, and <systemitem>-qarch=pwr8</systemitem> which selects the POWER8 ISA.</para>
    <programlisting>$ xlC -qarch=pwr8 -qaltivec test.cxx -o test.exe
</programlisting>
    <para>When compiling source code to examine the quality of code generation the program should be compiled with <systemitem>-O3</systemitem>. Both compilers consume <systemitem>-O3</systemitem>.</para>
  </section>
  <section id="power8_header">
    <title>Altivec headers</title>
    <para>The header required for datatypes and functions is <systemitem>&lt;altivec.h&gt;</systemitem>. To support compiles with a C++ compiler <systemitem>__vector</systemitem> keyword is used rather than <systemitem>vector</systemitem>. A typical Altivec include looks as shown below.</para>
    <programlisting>#if defined(__ALTIVEC__)
# include &lt;altivec.h&gt;
# undef vector
# undef pixel
# undef bool
#endif
</programlisting>
    <para>In addition to <systemitem>__ALTIVEC__</systemitem> preprocessor macro you will see the following defines depending on the platform:</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para><systemitem>__powerpc__</systemitem> and <systemitem>__powerpc</systemitem> on AIX
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__powerpc__</systemitem> and <systemitem>__powerpc64__</systemitem> on Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>_ARCH_PWR3</systemitem> through <systemitem>_ARCH_PWR9</systemitem> on AIX and Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__linux__</systemitem>, <systemitem>__linux</systemitem> and <systemitem>linux</systemitem> on Linux
        </para>
      </listitem>
      <listitem>
        <para><systemitem>_AIX</systemitem>, and <systemitem>_AIX32</systemitem> through <systemitem>_AIX72</systemitem> on AIX
        </para>
      </listitem>
      <listitem>
        <para><systemitem>__xlc__</systemitem> and <systemitem>__xlC__</systemitem> when using IBM XL C/C++
        </para>
      </listitem>
    </itemizedlist>
  </section>
  <section id="power8_endianess">
    <title>Machine endianness</title>
    <para>You will experience both little-endian and big-endian machines in the field when working with a modern PowerPC architecture. Linux is generally little-endian, while AIX is big-endian.</para>
    <para>When writing portable source code you should check the value of preprocessor macros <systemitem>__LITTLE_ENDIAN__</systemitem> or <systemitem>__BIG_ENDIAN__</systemitem> to determine the configuration. The value of the macros <systemitem>__BIG_ENDIAN__</systemitem> and <systemitem>__LITTLE_ENDIAN__</systemitem> are defined to non-0 to activate the macro. Source code checking endianness should look similar to the code shown below.</para>
    <programlisting>#if __LITTLE_ENDIAN__
# error "Little-endian system"
#else
# error "Big-endian system"
#endif
</programlisting>
    <para>The compilers can show the endian-related preprocessor macros available on a platform. Below is from GCC on <systemitem>gcc112</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-le.</para>
    <screen>$ g++ -dM -E test.cxx | grep -i endian
#define __ORDER_LITTLE_ENDIAN__ 1234
#define _LITTLE_ENDIAN 1
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __ORDER_PDP_ENDIAN__ 3412
#define __LITTLE_ENDIAN__ 1
#define __ORDER_BIG_ENDIAN__ 4321
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
</screen>
    <para>And the complimentary view from IBM XL C/C++ on <systemitem>gcc112</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-le.</para>
    <screen>$ xlC -qshowmacros -E test.cxx | grep -i endian
#define _LITTLE_ENDIAN 1
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
#define __LITTLE_ENDIAN__ 1
#define __ORDER_BIG_ENDIAN__ 4321
#define __ORDER_LITTLE_ENDIAN__ 1234
#define __ORDER_PDP_ENDIAN__ 3412
#define __VEC_ELEMENT_REG_ORDER__ __ORDER_LITTLE_ENDIAN__
</screen>
    <para>However, below is <systemitem>gcc119</systemitem> from the <link linkend="cfarm">compile farm</link>, which is ppc64-be. It runs AIX and notice <systemitem>__BYTE_ORDER__</systemitem>, <systemitem>__ORDER_BIG_ENDIAN__</systemitem> and <systemitem>__ORDER_LITTLE_ENDIAN__</systemitem> are not present.</para>
    <screen>$ xlC -qshowmacros -E test.cxx | grep -i endian
#define __BIG_ENDIAN__ 1
#define _BIG_ENDIAN 1
#define __THW_BIG_ENDIAN__ 1
#define __HHW_BIG_ENDIAN__ 1
</screen>
  </section>
  <section id="power8_alloc">
    <title>Memory allocation</title>
    <para>System calls like <systemitem>malloc</systemitem> and <systemitem>calloc</systemitem> (and friends) are used to acquire memory from the heap. The system calls <emphasis>do not</emphasis> guarantee alignment to any particular boundary on all platforms. Linux generally returns a pointer that is at least 16-byte aligned on all platforms, including ARM, PPC, MIPS and x86. AIX <emphasis>does not</emphasis> provide the same <ulink url="http://stackoverflow.com/q/48373188/608639">alignment behavior</ulink>.</para>
    <para>To avoid unexpected surprises when using heap allocations you should use <ulink url="http://pubs.opengroup.org/onlinepubs/009695399/functions/posix_memalign.html"><systemitem>posix_memalign</systemitem></ulink> to acquire heap memory aligned to a particular boundary and <systemitem>free</systemitem> to return it to the system.</para>
    <para>AIX provides routines for vector memory allocation and alignment. They are <systemitem>vec_malloc</systemitem> and <systemitem>vec_free</systemitem>, and you can use them like <systemitem>_mm_malloc</systemitem> on Intel machines with Streaming SIMD Extensions (SSE).</para>
  </section>
  <section id="power8_datatypes">
    <title>Vector datatypes</title>
    <para>Three vector datatypes are needed for in-core programming. The three types used for crypto are listed below.</para>
    <itemizedlist mark="bullet">
      <listitem>
        <para>
          <systemitem>__vector unsigned char</systemitem>
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>__vector unsigned int</systemitem>
        </para>
      </listitem>
      <listitem>
        <para>
          <systemitem>__vector unsigned long</systemitem>
        </para>
      </listitem>
    </itemizedlist>
    <para><systemitem>__vector unsigned char</systemitem> is arranged as 16 each 8-bit bytes, and it is typedef'd as <systemitem>uint8x16_p8</systemitem>. <systemitem>__vector unsigned int</systemitem> is arranged as 4 each 32-bit words, and it is typedef'd as <systemitem>uint32x4_p8</systemitem>.</para>
    <para>POWER8 added <systemitem>__vector unsigned long</systemitem> and associated vector operations. <systemitem>__vector unsigned long</systemitem> is arranged as 2 each 64-bit double words, and it is typedef'd as <systemitem>uint64x2_p8</systemitem>.</para>
    <para>The typedef naming was selected to convey the arrangement, like <systemitem>32x4</systemitem> and <systemitem>64x2</systemitem>. The trailing <systemitem>_p8</systemitem> was selected to avoid collisions with ARM NEON vector data types. The suffix <systemitem>_p</systemitem> (for POWER architecture) or <systemitem>_v</systemitem> (for Vector) would work just as well.</para>
  </section>
  <section id="power8_shift">
    <title>Vector shifts</title>
    <para>Altivec shifts and rotates are performed using <emphasis>Vector Shift Left Double by Octet Immediate</emphasis>. The vector shift and rotate built-in is <systemitem>vec_sld</systemitem> and it compiles/assembles to <systemitem>vsldoi</systemitem>. Both shift and rotate operate on a concatenation of two vectors. Bytes are shifted out on the left and shifted in on the right. The instructions need an integral constant in the range 0 - 15, inclusive.</para>
    <para>Vector shifts and rotates perform as expected on big-endian machines. Little-endian machines need a special handling to produce correct results and the <ulink url="http://www.ibm.com/support/knowledgecenter/SSXVZZ_13.1.4/com.ibm.xlcpp1314.lelinux.doc/compiler_ref/vec_sld.html">IBM manuals don't tell you about it</ulink>. If you are like many other developers then you will literally waste hours trying to figure it out what happened the first time you experience it.</para>
    <para>The issue is <ulink url="http://stackoverflow.com/q/46341923/608639">shifts and rotates are endian sensitive</ulink>, and you have to use <systemitem>16-n</systemitem> and swap vector arguments on little-endian systems. The C++ source code provides the following template function to compensate for the little-endian behavior.</para>
    <programlisting>template &lt;unsigned int N, class T&gt;
T VectorShiftLeft(const T val1, const T val2)
{
#if __LITTLE_ENDIAN__
    enum {R = (16-N)&amp;0xf};
    return vec_sld(val2, val1, R);
#else
    enum {R = N&amp;0xf};
    return vec_sld(val1, val2, R);
#endif
}
</programlisting>
    <para>A <systemitem>VectorRotateLeft</systemitem> would be similar to the code below, if needed. Rotate is a special case of shift where both vector arguments are the same value.</para>
    <programlisting>template &lt;unsigned int N, class T&gt;
T VectorRotateLeft(const T val)
{
#if __LITTLE_ENDIAN__
    enum {R = (16-N)&amp;0xf};
    return vec_sld(val, val, R);
#else
    enum {R = N&amp;0xf};
    return vec_sld(val, val, R);
#endif
}
</programlisting>
  </section>
  <section id="power8_permute">
    <title>Vector permutes</title>
    <para>Vector permutes allow you to rearrange elements in a vector. The values to be permuted can be in any arrangement like 64x2 or 32x4, but the mask is always an octet mask using an 8x16 arrangement.</para>
    <para>The Altivec permute is very powerful and it stands out among architectures like ARM, Aarch64 and x86. The POWER permute allows you to select elements from two source vectors. When an index in the mask is in the range <systemitem>[0,15]</systemitem> then elements from the first vector are selected, and index values in the the range <systemitem>[16,31]</systemitem> select elements from the second vector.</para>
    <para>As an example, suppose you have a big-endian byte array like a message to be hashed using SHA-256. SHA operates on 32-bit words so the message needs a permute on little-endian systems. The code to perform the permute on a little-endian machine would look like below.</para>
    <programlisting>uint32x4_p msg = vec_ld(/*load from memory*/);
uint8x16_p mask = {3,2,1,0, 7,6,5,4, 11,10,9,8, 15,14,13,12};
msg = vec_perm(msg, msg, mask);
</programlisting>
    <para>The previous example only needed one vector so it used <systemitem>msg</systemitem> twice in the call to <systemitem>vec_perm</systemitem>. The Altivec code is similar to <systemitem>_mm_shuffle_epi8</systemitem> on Intel machines. An example that interleaves two different vectors is shown below.</para>
    <programlisting>uint32x4_p a = { 0,  0,  0,  0};  // All 0 bits
uint32x4_p b = {-1, -1, -1, -1};  // All 1 bits
uint8x16_p m = {0,1,2,3, 16,17,18,19, 4,5,6,7, 20,21,22,23};
uint32x4_p c = vec_perm(a, b, m);
</programlisting>
    <para>After the code above executes the vector <systemitem>c</systemitem> will have the value <systemitem>{0, -1, 0, -1}</systemitem>.</para>
    <para>Below is the image IBM provides for the <systemitem>vec_perm</systemitem> documentation. The IBM example shows <systemitem>d = vec_perm(a, b, c)</systemitem>. The light grey blocks in vector <systemitem>d</systemitem> are from the first vector, and dark grey blocks in vector <systemitem>d</systemitem> are from the second vector.</para>
    <para/>
    <mediaobject>
      <imageobject>
        <imagedata fileref="images/vecperm.gif" width="5.5in" scalefit="1" format="GIF"/>
      </imageobject>
      <textobject>
        <phrase>Permute 16 8-bit integer elements.</phrase>
      </textobject>
    </mediaobject>
  </section>
  <section id="power8_vec_deref">
    <title>Vector dereferences</title>
    <para>
      The <ulink url="https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture">OpenPOWER ELF V2 ABI Specification</ulink>, version 1.4, incorrectly states that accessing vectors on Power should preferably be done with vector pointers and the dereference operator *.  However, this is only permitted for aligned vector references.  Examples in Chapter 6 of the ABI document show use of casting operations that represent undefined behavior according to the C standard.  An errata document that corrects the ABI may be found here: [TODO: Provide the URL once the technical problems with posting the errata have been overcome.]  Subsequent sections describe the proper way to use loads and stores of aligned and unaligned data.
    </para>
  </section>
  <section id="power8_aligned_ld_st">
    <title>Aligned data references</title>
    <para>Altivec loads and stores have traditionally been performed using <systemitem>vec_ld</systemitem> and <systemitem>vec_st</systemitem> since at least the POWER4 days in the early 2000s. <systemitem>vec_ld</systemitem> and <systemitem>vec_st</systemitem> are sensitive to alignment of the memory address and the offset into the address. The effective address is the sum <systemitem>address+offset</systemitem> rounded down or masked to a multiple of 16.</para>
    <para>Altivec <emphasis>does not</emphasis> raise a <systemitem>SIGBUS</systemitem> to indicate a misaligned load or store. Instead, the bottom 4 bits of the sum <systemitem>address+offset</systemitem> are masked-off and then the memory at the effective address is loaded.</para>
    <para>You can use the Altivec loads and stores when you <emphasis>control</emphasis> buffers and ensure they are 16-byte aligned, like an AES key schedule table. Otherwise just use <link linkend="power8_unaligned_ld_st">unaligned loads and stores</link> to avoid trouble.</para>
    <para>The C/C++ code to perform a load using <systemitem>vec_ld</systemitem> should look similar to below. Notice the <systemitem>assert</systemitem> to warn you of problems in debug builds.</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoad(const T* mem_addr, int offset)
{
#ifndef NDEBUG
    uintptr_t maddr = ((uintptr_t)mem_addr)+offset;
    uintptr_t mask = ~(uintptr_t)0xf;
    uintptr_t eaddr = maddr &amp; mask;
    assert(maddr == eaddr);
#endif

    return (uint32x4_p8)vec_ld(offset, (uint8_t*)mem_addr);
}
</programlisting>
    <para>The C/C++ code to perform a store using <systemitem>vec_st</systemitem> should look similar to below.</para>
    <programlisting>template &lt;class T&gt;
void VectorStore(const uint32x4_p8 val, T* mem_addr, int offset)
{
#ifndef NDEBUG
    uintptr_t maddr = ((uintptr_t)mem_addr)+offset;
    uintptr_t mask = ~(uintptr_t)0xf;
    uintptr_t eaddr = maddr &amp; mask;
    assert(maddr == eaddr);
#endif

    vec_st((uint8x16_p8)val, offset, (uint8_t*)mem_addr);
}
</programlisting>
<!--
    <para>Casting away <systemitem>const</systemitem>-ness on <systemitem>mem_addr</systemitem> is discussed in <link linkend="power8_const_ptr"><systemitem>const</systemitem> pointers</link> below.</para>
-->
  </section>
  <section id="power8_unaligned_ld_st">
    <title>Unaligned data references</title>
    <para>POWER7 (PowerISA 2.07) introduced unaligned loads and stores that avoid the aligned memory requirements. The preferred intrinsic functions for unaligned loads and stores are <systemitem>vec_xl</systemitem> and <systemitem>vec_xst</systemitem>.  Theses are available on all currently supported versions of GCC and XLC; however, older versions of GCC such as those installed on many enterprise Linux distributions do not supply them.  For compatibility with these older compilers, you may use <systemitem>vec_vsx_ld</systemitem> and <systemitem>vec_vsx_st</systemitem> for GCC.</para>
    <para>You should use the POWER7 loads and stores whenever you <emphasis>do not control</emphasis> buffers or their alignments, like messages supplied by user code.</para>
    <para>The C/C++ code to perform a load using <systemitem>vec_xl</systemitem> and <systemitem>vec_vsx_ld</systemitem> should look similar to below. The function name has a <systemitem>u</systemitem> added to indicate unaligned.</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoadu(const T* mem_addr, int offset)
{
#if defined(__xlc__) || defined(__xlC__)
    return (uint32x4_p8)vec_xl(offset, (uint8_t*)mem_addr);
#else
    return (uint32x4_p8)vec_vsx_ld(offset, (uint8_t*)mem_addr);
#endif
}
</programlisting>
    <para>The C/C++ code to perform a store using <systemitem>vec_xst</systemitem> and <systemitem>vec_vsx_st</systemitem> should look similar to below.</para>
    <programlisting>template &lt;class T&gt;
void VectorStoreu(const uint32x4_p8 val, T* mem_addr, int offset)
{
#if defined(__xlc__) || defined(__xlC__)
    vec_xst((uint8x16_p8)val, offset, (uint8_t*)mem_addr);
#else
    vec_vsx_st((uint8x16_p8)val, offset, (uint8_t*)mem_addr);
#endif
}
</programlisting>
    <para>If your code will only be compiled with supported compilers, you may simplify it to use the vec_xl and vec_xst variants for both XLC and GCC.</para>

<!--
    <para>Casting away <systemitem>const</systemitem>-ness on <systemitem>mem_addr</systemitem> is discussed in <link linkend="power8_const_ptr"><systemitem>const</systemitem> pointers</link> below.</para>
-->
  </section>
  <section id="power8_vec_ld_be">
    <title>Big-endian data references</title>
    <para>POWER7 introduced <systemitem>vec_xl_be</systemitem> and <systemitem>vec_st_be</systemitem> which perform big-endian loads and stores. The big-endian load compiles/assembles to <systemitem>lxvw4x/lxvd2x</systemitem>, and the store compiles/assembles to <systemitem>stxvw4x/stxvd2x</systemitem>.</para>
    <para>The big-endian variants can save two instructions on little-endian systems when the little-endian byte swap is not needed. This usually happens when you need to permute the data after a load or before a store.</para>
    <para>The extraneous permutes can be seen in the disassembly below. The interleaved instructions were removed. The instructions which remain are (1) a load of the value, (2) a load of the mask, and (3) three permutations instead of one.</para>
    <programlisting>$ objdump --disassemble sha256-p8.exe

SHA256_SCHEDULE(unsigned int*, unsigned char const*):
...
100008a8:   99 4e 00 7c     lxvd2x  vs32,0,r9
100008bc:   99 26 20 7c     lxvd2x  vs33,0,r4
100008cc:   57 02 00 f0     xxswapd vs32,vs32
100008d0:   57 0a 21 f0     xxswapd vs33,vs33
100008d4:   97 05 00 f0     xxlnand vs32,vs32,vs32
100008d8:   2b 08 21 10     vperm   v1,v1,v1,v0
...
</programlisting>
    <para>While not readily apparent, <systemitem>v0</systemitem> is another name for <systemitem>vs32</systemitem>, and <systemitem>v1</systemitem> is another name for <systemitem>vs33</systemitem>. So the permutation may be thought of as <systemitem>vperm vs33,vs33,vs33,vs32</systemitem> (although this will not assemble). Also see <ulink url="https://stackoverflow.com/q/49132339/608639">What does “vperm v0,v0,v0,v17” with unused v0 do?</ulink>.</para>
    <para>Access to <systemitem>vec_xl_be</systemitem> and <systemitem>vec_st_be</systemitem> was provided for IBM XL C/C++, but GCC only supports these intrinsic functions beginning with version 8 (Spring 2018 release).  For earlier versions of GCC, you must use inline assembly to replace the missing built-ins with <systemitem>VEC_XL_BE</systemitem> and <systemitem>VEC_ST_BE</systemitem>.</para>
    <para>
      <emphasis role="italic">WJS: Is it intended to provide definitions of these macros here?</emphasis>
    </para>
    <para>JWW: Here are my functions to load a user message for use with SHA-256. I benchmarked them on GCC112, which is ppc64-le @3.4 GHz. I lose 2-3 cpb when using the replacement <systemitem>VEC_XL_BE</systemitem>. We may need to drop them as technically unfeasible.</para>
    <programlisting>uint32x4_p8 VEC_XL_BE(int offset, uint8_t* data)
{
#if defined(__xlc__) || defined(__xlC__)
    return vec_xl_be(offset, data);
#else
    uint32x4_p8 res;
    __asm(" lxvw4x  %x0, %1, %2    \n\t"
          : "=wa" (res)
          : "b" (data), "r" (offset),
            "m" (*(unsigned char (*)[16]) &amp;data[offset]));
    return res;
#endif
}

template &lt;class T&gt; static inline
uint32x4_p8 VectorLoadMsg32x4(const T* data, int offset)
{
#if __LITTLE_ENDIAN__
    const uint8x16_p8 mask = {11,10,9,8, 15,14,13,12, 3,2,1,0, 7,6,5,4};
    const uint32x4_p8 res = VEC_XL_BE(offset, (uint8_t*)data);
    return (uint32x4_p8)vec_perm(res, res, mask);
#else
    return VEC_XL_BE(offset, (uint8_t*)data);
#endif
}
</programlisting>
  </section>

<!--
  <section id="power8_const_ptr">
    <title>Const pointers</title>
    <para>The Altivec built-ins have unusual behavior when using <systemitem>const</systemitem> pointers during a load operation. A program runs slower when the memory is marked as <systemitem>const</systemitem>. The behavior has been witnessed in two libraries on different machines and the decrease in performance is measurable. For example, <ulink url="http://github.com/randombit/botan/pull/1459">AES runs 0.3 cycles per byte (cpb) faster</ulink> when non-<systemitem>const</systemitem> pointers are used for loads. 0.3 cpb may not sound like much but it equates to 200 MiB/s for AES-128 on <systemitem>gcc112</systemitem>.</para>
    <para>Source code using the <systemitem>non-const</systemitem> pointers should look similar to below:</para>
    <programlisting>template &lt;class T&gt;
uint32x4_p8 VectorLoad(const T* mem_addr, int offset)
{
    // mem_addr must be aligned to 16-byte boundary
    return (uint32x4_p8)vec_ld(offset, (uint8_t*)mem_addr);
}
</programlisting>
-->
  </section>
</chapter>
